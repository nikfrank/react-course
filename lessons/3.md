Lesson 3

multi view event planning

```
cd ~/code/react-course
git clone https://github.com/nikfrank/react-course-workbook-3
cd react-course-workbook-3
yarn
npm start
```

I've built here for you a tabs behaviour to start with - nothing special

we're going to fill in the tabs (a details form, a shopping list, and an invites list)

then we're going to split each tab into a Component, and use props to send data to the component and function calls back up

this is going to be our first refactor!

## core concepts:

### Don't Repeat Yourself (DRY)

imagine we have

```js
import React, { Component } from 'react';

class TwoCounters extends Component {
  state = { count0: 0, count1: 0 }

  incCounter = counterName=> ()=>
    this.setState({ [counterName]: this.state[counterName] + 1 })

  reset = counterName=> ()=> this.setState({ [counterName]: 0 })

  render(){
    const { count0, count1 } = this.state;

    return (
      <div>
        <div className='counter'>
          <span>{count0}</span>
          <button onClick={this.incCounter('count0')}>++</button>
          <button onClick={this.reset('count0')}>reset</button>
        </div>
        <div className='counter'>
          <span>{count1}</span>
          <button onClick={this.incCounter('count1')}>++</button>
          <button onClick={this.reset('count1')}>reset</button>
        </div>
      </div>
    );
  }
}
```

(you can copy paste this into your app if you want to see it running)

You might notice that we're repeating ourself in our render

we have the same ```div.counter``` twice! just the value of the ```counterName``` we pass to our [curried](https://blog.benestudio.co/currying-in-javascript-es6-540d2ad09400) event handlers is different.

so what you should be asking is: Why Everything Twice? (WET being the opposite of DRY)


so for many reasons (code maintainability, laziness, ...) we want to write this Counter once and use it twice (or three hundred times even)

that way if we make any updates to the Counter, it will be reflected everywhere!

the whole point of React's Component is to make it easy to do something like this.

What we'll do is make a Counter Component, which will need props: ```count``` for its current value, and an ```onChange``` function prop to call when we want to change it

```js
import React, { Component } from 'react';

class Counter extends Component {
  render(){
    const { count, onChange } = this.props;

    return (
      <div className='counter'>
        <span>{count}</span>
        <button onClick={()=> onChange(count+1)}>++</button>
        <button onClick={()=> onChange(0)}>reset</button>
      </div>
    );
  }
}

class TwoCounters extends Component {
  state = { count0: 0, count1: 0 }

  change = counterName=> value=> this.setState({ [counterName]: value })

  render(){
    const { count0, count1 } = this.state;
    
    return (
      <div>
        <Counter count={count0} onChange={this.change('count0')} />
        <Counter count={count1} onChange={this.change('count1')} />
      </div>
    );
  }
}
```

so now it's a lot easier to do new things!

let's say we want a double button

```js
import React, { Component } from 'react';

class Counter extends Component {
  render(){
    const { count, onChange } = this.props;

    return (
      <div className='counter'>
        <span>{count}</span>
        <button onClick={()=> onChange(count+1)}>++</button>
        <button onClick={()=> onChange(0)}>reset</button>
        <button onClick={()=> onChange(count*2)}>double</button>
      </div>
    );
  }
}
```

that was easy!

so that's the basics of props & Components, using them to dry out [refactor] our code.


---


now the actual lesson

(( if you want to write the tabs as an exercise, ```git checkout start```... that's not the main lesson here so we'll start with step0 ))


### getting started

```git checkout step0```


let's write our first tab


##### promo details

promo details is a form that updates a few values in the state

```js
//...

state = {
  name: '',
  imgSrc: '',
  eventType: '',
}

//...

setName = ({ target: { value } })=> this.setState({ name: value })
setImgSrc = ({ target: { value } })=> this.setState({ imgSrc: value })
setEventType = ({ target: { value } })=> this.setState({ eventType: value })

//...

render(){
  return (
  //...
    <div className='promo-tab'>
      <label htmlFor='name'>Name</label>
      <input id='name' value={name} onChange={this.setName}/>

      <label htmlFor='imgSrc'>Picture url</label>
      <input id='imgSrc' value={imgSrc} onChange={this.setImgSrc}/>

      <label htmlFor='eventType'>Event Type</label>
      <input id='eventType' value={eventType} onChange={this.setEventType}/>      
    </div>
  //...
  );
}
```

same as last time, pretty easy!




### step 1 the shopping list

```
git status # we should have work from step0
git commit -am "all that work from step0"
git checkout step1

# if we want to keep all that work from step0
git merge step0
```

This is basically a todo list (which if you've ever done any front end application development before you'll be familiar with)

which is to say, it's made up of some very standard parts:

- inital state (empty array)
- add new item (item schema)
- edit existing item (update handler functions)
- remove item (similar instance function as update)

if you're familiar with CRUD (Create, Read, Update, Delete) as a pattern for APIs, you'll see the connection here

- ```addShoppingItem = ()=> /* ... */``` = Create
- ```{ this.state.shoppingList.map( item => (/* ... */) ) }``` is our Read
- ```updateListValue = ()=> /* ... */``` = Update
- ```removeShoppingItem = ()=> /* ... */``` = Delete

now we just need to fill these in!


##### initial state

```js
state = { shoppingList: [] }
```

should do


##### add new item

```js
  addShoppingItem = ()=>
    this.setState(state => ({
      shoppingList: state.shoppingList.concat({ item: '', quantity: 0 })
    }) )
```

here we're using ```setState```'s [update function param](https://reactjs.org/docs/react-component.html#setstate) instead of just passing an object.

the schema for our shopping list will be

```js
{ item: String, quantity: Number }
```

which is why we're initializing new items to

```js
{ item: '', quantity: 0 }
```

[array concat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) is an easy way to make a new array with all the old elements and more on the end

let's also make a button to call this function with

```js
(currentTab === 1) ? (
  <div className='shopping-list'>
    <button onClick={this.addShoppingItem}>+</button>
  </div>
)
```

and then we'll want to render the new items!

```js
render(){
  const { shoppingList } = this.state;

  //...
  <ul>
    {
      shoppingList.map( ({ item, quantity }, sli)=> (
        <li key={sli}>
          <label htmlFor={`${sli}-sli-item`}>item</label>
          <input id={`${sli}-sli-item`} value={item}/>

          <label htmlFor={`${sli}-sli-quantity`}>quantity</label>
          <input id={`${sli}-sli-quantity`} value={quantity} type='number'/>
        </li>
      ) )
    }
  </ul>
  //...
}
```


##### update existing items

you'll see if you try that our current list inputs don't let us update the values!

we can make an item, but then it's stuck forever as '' 0. hmmm.

let's make some functions for updating the values then already


```js
  setListItem = ({ target: { value, id } })=> {
    const index = parseInt(id, 10);
    
    this.setState(state => ({
      shoppingList: state.shoppingList.map( (listItem, sli)=>
        (sli !== index) ? listItem : {...listItem, item: value}
      )
    }) )
  }

  setListQuantity = ({ target: { value, id } })=> {
    const index = parseInt(id, 10);
    
    this.setState(state => ({
      shoppingList: state.shoppingList.map( (listItem, sli)=>
        (sli !== index) ? listItem : {...listItem, quantity: value}
      )
    }) )
  }
```

there's a couple of things going on here we should talk about

firstly - we could refactor these two functions into one, it'd be a bit more complex though - so I'll leave that as an exercise

let's walk through

we get the ```value``` and ```id``` props from our input element

we'll set the item/quantity in the state to ```value```, and we'll use the ```id``` to figure out which shoppingList element we should be updating

```js
const index = parseInt(id, 10);
```
 takes the number off the front of the ```id``` prop and reads it in base 10 (ie normally)

we're using the setState updater function again, and this time we're computing a new array to put in place of the old ```state.shoppingList```

```js
state.shoppingList.map( (listItem, sli)=>
  (sli !== index) ? listItem : {...listItem, quantity: value}
)
```

so if the index (sli := 'shopping list index') isn't the same as the index we computed from the ```id``` prop param, the ```map``` function returns the old item in place

if it *is* the same, we should put a new item there exactly the same as the old one, but with ```quantity``` overwritten withe ```value``` we got as a param.

the same thing is happening on the other function, just withe other field.


we'll want to trigger these functions from our list item inputs too!

```js
<input id={`${sli}-sli-item`}
       value={item}
       onChange={this.setListItem}/>
```

etc.


if you want to refactor those two functions together, you could parse also the name of the field from the ```id``` prop param, and use that to overwrite the field you want.


##### removing items

if you got the pattern yet, you can guess what we're going to do

- write a function on our Component to do what the user expects (remove the item)
- bind that function in our render (we should make a new button here with an X on it)


in our ```<li>```

```js
<button value={sli} onClick={this.removeShoppingItem}>X</button>
```

so then we need a ```removeShoppingItem``` function

the ```value``` prop we'll use in the ```removeShoppingItem``` function to know which item to remove


```js
removeShoppingItem = ({ target: { value } })=>
  this.setState(state => ({
    shoppingList: state.shoppingList.slice(0, value*1)
                       .concat( state.shoppingList.slice( value*1 +1 ) )
  }) )
```

( the ```value*1``` is how I'm casting ```value``` to a Number... button values get casted to string by the DOM )

all the [slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) calls do here is compute the part of the array before and after the element we're removing. Then concat puts those two together, which gives us what we want.


so now you've written your [maybe] first list app.



### step 2 the invitation list

```
git status # we should have work from step1
git commit -am "all that work from step1"
git checkout step2

# if we want to keep all that work from step1
git merge step1
```

this is actually a simpler version of our shopping list




### step 3 the refactor!

```
git status # we should have work from step2
git commit -am "all that work from step2"
git checkout step3

# if we want to keep all that work from step2
git merge step2
```


no new features here. we're going to take our App.js, which has become very long and of many concerns - and split it apart (to get SOC: Separation Of Concerns)

the only new code we'll write is to connect our App.js (which is our view and state component) to our feature components (```<Promo/> <ShoppingList/> and <Invitations/>```)



---




[back to index](https://github.com/nikfrank/react-course)

[prev lesson](./2.md)

[next lesson](./4.md)