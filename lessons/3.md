Lesson 3

multi view event planning

[workbook 3 - plan a party](https://github.com/nikfrank/react-course-workbook-3)

```
cd ~/code/react-course
git clone https://github.com/nikfrank/react-course-workbook-3
cd react-course-workbook-3
yarn
npm start
```

**NOTICE**
```
This lesson continues learning about core React concepts and application organization.
If you've completed [Lesson 2 (work for Snoop)](./2.md),
you'll also be ready for [Lesson 4](./4.md), where API calls are introduced.
Some students will want to learn that right away, so feel free!
```
**END of NOTICE**


I've built here for you a tabs behaviour to start with - nothing special

we're going to fill in the tabs (a details form, a shopping list, and an invites list)

then we're going to split each tab into a Component, and use props to send data to the component and function calls back up

this is going to be our first refactor!

## core concepts:

### Don't Repeat Yourself (DRY)

imagine we have

```js
import React, { Component } from 'react';

class TwoCounters extends Component {
  state = { count0: 0, count1: 0 }

  incCounter = counterName=> ()=>
    this.setState({ [counterName]: this.state[counterName] + 1 })

  reset = counterName=> ()=> this.setState({ [counterName]: 0 })

  render(){
    const { count0, count1 } = this.state;

    return (
      <div>
        <div className='counter'>
          <span>{count0}</span>
          <button onClick={this.incCounter('count0')}>++</button>
          <button onClick={this.reset('count0')}>reset</button>
        </div>
        <div className='counter'>
          <span>{count1}</span>
          <button onClick={this.incCounter('count1')}>++</button>
          <button onClick={this.reset('count1')}>reset</button>
        </div>
      </div>
    );
  }
}
```

(you can copy paste this into your app if you want to see it running)

You might notice that we're repeating ourself in our render

we have the same ```div.counter``` twice! just the value of the ```counterName``` we pass to our [curried](https://blog.benestudio.co/currying-in-javascript-es6-540d2ad09400) event handlers is different.

so what you should be asking is: Why Everything Twice? (WET being the opposite of DRY)


so for many reasons (code maintainability, laziness, ...) we want to write this Counter once and use it twice (or three hundred times even)

that way if we make any updates to the Counter, it will be reflected everywhere!

the whole point of React's Component is to make it easy to do something like this.

What we'll do is make a Counter Component, which will need props: ```count``` for its current value, and an ```onChange``` function prop to call when we want to change it

```js
import React, { Component } from 'react';

class Counter extends Component {
  render(){
    const { count, onChange } = this.props;

    return (
      <div className='counter'>
        <span>{count}</span>
        <button onClick={()=> onChange(count+1)}>++</button>
        <button onClick={()=> onChange(0)}>reset</button>
      </div>
    );
  }
}

class TwoCounters extends Component {
  state = { count0: 0, count1: 0 }

  change = counterName=> value=> this.setState({ [counterName]: value })

  render(){
    const { count0, count1 } = this.state;
    
    return (
      <div>
        <Counter count={count0} onChange={this.change('count0')} />
        <Counter count={count1} onChange={this.change('count1')} />
      </div>
    );
  }
}
```

(here I'm using ES6's [computed property names](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer) feature to set ```state.count0``` or ```state.count1``` depending on which is passed to the first fat arrow)

so now it's a lot easier to do new things!

let's say we want a double button

```js
import React, { Component } from 'react';

class Counter extends Component {
  render(){
    const { count, onChange } = this.props;

    return (
      <div className='counter'>
        <span>{count}</span>
        <button onClick={()=> onChange(count+1)}>++</button>
        <button onClick={()=> onChange(0)}>reset</button>
        <button onClick={()=> onChange(count*2)}>double</button>
      </div>
    );
  }
}
```

that was easy!

so that's the basics of props & Components, using them to dry out [refactor] our code.


---


now the actual lesson

(( if you want to write the tabs as an exercise, ```git checkout start```... that's not the main lesson here so we'll start with step0 ))


### getting started

```git checkout step0```


let's write our first tab


##### promo details

promo details is a form that updates a few values in the state

```js
//...

state = {
  name: '',
  imgSrc: '',
  eventType: '',
}

//...

setName = ({ target: { value } })=> this.setState({ name: value })
setImgSrc = ({ target: { value } })=> this.setState({ imgSrc: value })
setEventType = ({ target: { value } })=> this.setState({ eventType: value })

//...

render(){
  return (
  //...
    <div className='promo-tab'>
      <label htmlFor='name'>Name</label>
      <input id='name' value={name} onChange={this.setName}/>

      <label htmlFor='imgSrc'>Picture url</label>
      <input id='imgSrc' value={imgSrc} onChange={this.setImgSrc}/>

      <label htmlFor='eventType'>Event Type</label>
      <input id='eventType' value={eventType} onChange={this.setEventType}/>      
    </div>
  //...
  );
}
```

same as last time, pretty easy!




### step 1 the shopping list

```
git status # we should have work from step0
git commit -am "all that work from step0"
git checkout step1

# if we want to keep all that work from step0
git merge step0
```

This is basically a todo list (which if you've ever done any front end application development before you'll be familiar with)

which is to say, it's made up of some very standard parts:

- initial state (empty array)
- add new item (item schema)
- edit existing item (update handler functions)
- remove item (similar instance function as update)

if you're familiar with CRUD (Create, Read, Update, Delete) as a pattern for APIs, you'll see the connection here

- ```addShoppingItem = ()=> /* ... */``` = Create
- ```{ this.state.shoppingList.map( item => (/* ... */) ) }``` is our Read
- ```updateListValue = ()=> /* ... */``` = Update
- ```removeShoppingItem = ()=> /* ... */``` = Delete

now we just need to fill these in!


##### initial state

```js
state = { shoppingList: [] }
```

should do


##### add new item

```js
  addShoppingItem = ()=>
    this.setState(state => ({
      shoppingList: state.shoppingList.concat({ item: '', quantity: 0 })
    }) )
```

here we're using ```setState```'s [update function param](https://reactjs.org/docs/react-component.html#setstate) instead of just passing an object.

the schema for our shopping list will be

```js
{ item: String, quantity: Number }
```

which is why we're initializing new items to

```js
{ item: '', quantity: 0 }
```

[array concat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) is an easy way to make a new array with all the old elements and more on the end

let's also make a button to call this function with

```js
(currentTab === 1) ? (
  <div className='shopping-list'>
    <button onClick={this.addShoppingItem}>+</button>
  </div>
)
```

and then we'll want to render the new items!

```js
render(){
  const { shoppingList } = this.state;

  //...
  <ul>
    {
      shoppingList.map( ({ item, quantity }, sli)=> (
        <li key={sli}>
          <label htmlFor={`${sli}-sli-item`}>item</label>
          <input id={`${sli}-sli-item`} value={item}/>

          <label htmlFor={`${sli}-sli-quantity`}>quantity</label>
          <input id={`${sli}-sli-quantity`} value={quantity} type='number'/>
        </li>
      ) )
    }
  </ul>
  //...
}
```


##### update existing items

you'll see if you try, our current list inputs don't let us update the values!

we can make an item, but then it's stuck forever as '' 0. hmmm.

let's make some functions for updating the values then already


```js
  setListItem = ({ target: { value, id } })=> {
    const index = parseInt(id, 10);
    
    this.setState(state => ({
      shoppingList: state.shoppingList.map( (listItem, sli)=>
        (sli !== index) ? listItem : {...listItem, item: value}
      )
    }) )
  }

  setListQuantity = ({ target: { value, id } })=> {
    const index = parseInt(id, 10);
    
    this.setState(state => ({
      shoppingList: state.shoppingList.map( (listItem, sli)=>
        (sli !== index) ? listItem : {...listItem, quantity: value}
      )
    }) )
  }
```

there's a couple of things going on here we should talk about

firstly - we could refactor these two functions into one, it'd be a bit more complex though - so I'll leave that as an exercise

let's walk through

we get the ```value``` and ```id``` props from our input element

we'll set the item/quantity in the state to ```value```, and we'll use the ```id``` to figure out which shoppingList element we should be updating

```js
const index = parseInt(id, 10);
```
 takes the number off the front of the ```id``` prop and reads it in base 10 (ie normally)

we're using the setState updater function again, and this time we're computing a new array to put in place of the old ```state.shoppingList```

```js
state.shoppingList.map( (listItem, sli)=>
  (sli !== index) ? listItem : {...listItem, quantity: value}
)
```

so if the index (sli := 'shopping list index') isn't the same as the index we computed from the ```id``` prop param, the ```map``` function returns the old item in place

if it *is* the same, we should put a new item there exactly the same as the old one, but with ```quantity``` overwritten withe ```value``` we got as a param.

the same thing is happening on the other function, just withe other field.


we'll want to trigger these functions from our list item inputs too!

```js
<input id={`${sli}-sli-item`}
       value={item}
       onChange={this.setListItem}/>
```

etc.


if you want to refactor those two functions together, you could parse also the name of the field from the ```id``` prop param, and use that to overwrite the field you want (using the computed property names feature we saw in the example!)


##### removing items

if you got the pattern yet, you can guess what we're going to do

- write a function on our Component to do what the user expects (remove the item)
- bind that function in our render (we should make a new button here with an X on it)


in our ```<li>```

```js
<button value={sli} onClick={this.removeShoppingItem}>X</button>
```

so then we need a ```removeShoppingItem``` function

the ```value``` prop we'll use in the ```removeShoppingItem``` function to know which item to remove


```js
removeShoppingItem = ({ target: { value } })=>
  this.setState(state => ({
    shoppingList: state.shoppingList.slice(0, value*1)
                       .concat( state.shoppingList.slice( value*1 +1 ) )
  }) )
```

( the ```value*1``` is how I'm casting ```value``` to a Number... button values get casted to string by the DOM )

all the [slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) calls do here is compute the part of the array before and after the element we're removing. Then concat puts those two together, which gives us what we want.


so now you've written your [maybe] first list app.



### step 2 the invitation list

```
git status # we should have work from step1
git commit -am "all that work from step1"
git checkout step2

# if we want to keep all that work from step1
git merge step1
```

this is actually a simpler version of our shopping list

let's start with what we're adding to the state

```js
state = {
  invites: [],
  newInvite: '',
}
```

we'll need an input box for the name of the next person we're going to invite

```js
setNewInvite = ({ target: { value } })=> this.setState({ newInvite: value })

//...

<label htmlFor='new-invite'>New invite - To</label>
<input value={newInvite} onChange={this.setNewInvite} id='new-invite'/>
```

and a ```this.addInvite``` method

```js
addInvite = ()=>
  this.setState(state => ({
    invites: state.invites.concat({ to: state.newInvite, status: '' }),
  }) )
```

but we'll want the input box cleared when we add the invitation

```js
addInvite = ()=>
  this.setState(state => ({
    invites: state.invites.concat({ to: state.newInvite, status: '' }),
    newInvite: '',
  }) )

//...

<button onClick={this.addInvite}>+</button>
```

of course we'll need a way to update the rsvp status for an invite

```js
rsvp = ({ target: { value, id } })=> {
  const index = parseInt(id, 10);

  this.setState(state => ({
    invites: state.invites.map( (invite, ii)=>
      (index !== ii) ? invite : ({
        ...invite, status: value,
      }) ),
  }) );
}
```

using the same id -> parseInt trick we used before to update the correct invite

so let's put it together in the render (remembering to make the id work with our trick)

```js
<ul>
  {
    invites.map( ({ to, status }, ii)=> (
      <li key={ii}>
        To: {to}
        <select value={status} id={`${ii}-rsvp`}
                onChange={this.rsvp}>
          <option value=''>No RSVP</option>
          <option value='confirmed'>Confirmed</option>
          <option value='Maybe'>Maybe</option>
        </select>
      </li>
    ))
  }
</ul>
```

not so bad - to write a quick feature like a list we can add to and edit all we needed was

- an add function (4 lines)
- an update function for the new item (1 line)
- an update function for an existing item (6 lines)
- to render the list (12 lines of JSX)


most of the time, writing a *feature* in React can be boiled down to render plus a few short functions

even in the next workbook when we start working with async / network behaviour (like asking an API for the data for our list) we'll still just be writing a render plus a few short functions.


---


at this point we've written all the features we'll write in this workbook and so it is a good time to pause and write some CSS.

The main drive of this course is to learn React, and so I won't walk you through the CSS - instead I will leave a list of links here of very useful rules to learn (which if you checkout the next step's branch you'll see me using!)

in general, I see my skills with CSS more like baking and less like cooking (that is to say, I work well with talented designers)

however, sometimes we don't get talented designers on our team, and so should develop some sense of style no?

- [box model basics](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model)
- [text basics](https://www.w3schools.com/css/css_text.asp)
- [css display property](https://developer.mozilla.org/en-US/docs/Web/CSS/display)
- [css position property](https://developer.mozilla.org/en-US/docs/Web/CSS/position)
- [borders and outlines](https://developer.mozilla.org/en-US/docs/Web/CSS/border)
- [styling lists](https://developer.mozilla.org/en-US/docs/Web/CSS/list-style)
- [css flex box](https://developer.mozilla.org/en-US/docs/Web/CSS/list-style)
- [animations](https://www.w3schools.com/css/css3_animations.asp)
- [styling the cursor](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor)
- [transforms](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)
- [z index](https://developer.mozilla.org/en-US/docs/Web/CSS/z-index)
- [css calc function](https://developer.mozilla.org/en-US/docs/Web/CSS/calc)
- [using css in React](https://reactjs.org/docs/faq-styling.html)


also, if you want to flex your skills from workbook-2, try putting validation on some of our inputs:

- enforce uniqueness on invite names
- enforce non-negative values for quantities on our shopping list (-1 would mean we need to sell?)
- use a regex to enforce a valid url on the imgSrc (and make sure it's an image)
- render the imgSrc that the user puts in


### step 3 the refactor!

```js
"Explain yourself as simply as possible, not one bit simpler"
    - Einstein
```

```
git status # we should have work from step2
git commit -am "all that work from step2"
git checkout step3

# if we want to keep all that work from step2
git merge step2
```

This is the most important part of this workbook. Take your time withe material, it's more philosophical than what we've been doing so far.

Give [React's Component and Props docs](https://reactjs.org/docs/components-and-props.html) a read for some context about what we're working with here.


Refactor === no new features. We're going to take our App.js, which has become very long (163 lines is tooooooo much. ideally we have no file > 100 LOC) and of many concerns (App houses the handler functions for three entirely separate views) - and split it apart (to get SOC: Separation Of Concerns)

the only new code we'll write is to connect our App.js (which is our view and state component) to our feature components (```<Promo/> <ShoppingList/> and <Invites/>```)

let's start by making a file for each of our new Components and putting the boilerplate React Component code in there.

```
touch ./src/Promo.js
touch ./src/ShoppingList.js
touch ./src/Invites.js
```

```js
import React, { Component } from 'react';

export default Promo extends Component {
  render(){
    return (
      <div>
        Put Promo stuff here
      </div>
    );
  }
};
```

(similarly for the other two)

(((
in a production app we might also add a css file for each Component (Promo.css)

and

```js
import './Promo.css';
```
from in that Component

here, we're just going to refactor our javascript, as we have some pretty general styles already.
)))


Now our goal is to make our App.js AS SIMPLE AS POSSIBLE AND NO SIMPLER

The way we'll accomplish this is by moving the logic (read: handler functions) and JSX specific to each tab into that tab's Component, then sending the state values to the Components via props, and binding onChange handlers to props as needed.


our current list of handlers is very long and have signatures specific to the rendered input elements

```js
  setName = ({ target: { value } })=> //...
  setImgSrc = ({ target: { value } })=> //...
  setEventType = ({ target: { value } })=> //...

  addShoppingItem = ()=> //...
  removeShoppingItem = ({ target: { value } })=> //...
  setListItem = ({ target: { value, id } })=> //...
  setListQuantity = ({ target: { value, id } })=> //...
  
  setNewInvite = ({ target: { value } })=> //...
  addInvite = ()=> //...

  rsvp = ({ target: { value, id } })=> //...
````

it would be simpler [preferable] if we had something like

```js
  setName = name=> this.setState({ name })
  setImgSrc = imgSrc=> this.setState({ imgSrc })
  setEventType = eventType=> this.setState({ eventType })

  onChangeShoppingList = shoppingList => this.setState({ shoppingList })
  
  onChangeInvites = invites => this.setState({ invites })
```

to make it so, we'll need our Components to call these new handlers back withe new values already computed

- addShoppingItem
- removeShoppingItem
- setListItem
- setListQuantity

-> onChangeShoppingList

and

- setNewInvite
- addInvite
- rsvp

-> onChangeInvites

 
as well as signature changes for

- setName
- setEventType
- setImgSrc


also, it'd be better if we could move the imgSrc validation into the Promo, so it never pollutes our Event state (App.js should really be renamed Event.js even)


---

##### Promo

so let's render our new ```Promo``` Component into ```App``` so we can start moving code around:

```jsx
import Promo from './Promo';

//...

<Promo setName={this.setName}
       name={name}
       setImgSrc={this.setImgSrc}
       imgSrc={imgSrc}
       setEventType={this.setEventType}
       eventType={eventType}/>
```

and so

```jsx
<div className='promo-tab form-field'>
  <label htmlFor='name'>Name</label>
  <input id='name' value={name} onChange={this.setName}/>

  <label htmlFor='imgSrc'>Picture url</label>
  <input id='imgSrc' value={imgSrc} onChange={this.setImgSrc}/>

  <label htmlFor='eventType'>Event Type</label>
  <input id='eventType' value={eventType} onChange={this.setEventType}/>

  {imgSrcValid && (<img src={imgSrc} alt='event'/>)}
</div>
```

can be moved into ```./src/Promo.js```


now, inside ```Promo```, we have access to ```this.props.setName``` and all the other props we've passed in from ```App```

React will update-render our Promo Component whenever his ```.props``` change, just like he's been update-rendering our ```App``` Component every time his ```.state``` changed. 


let's move our input handling logic to inside ```Promo```

```js
import React, { Component } from 'react';

const imageUrlRegex = /(http)?s?:?(\/\/[^"']*\.(?:png|jpg|jpeg|gif|png|svg))/i;

export default class Promo extends Component {
  state = { imgSrcValid: !!imageUrlRegex.exec(this.props.imgSrc) }

  setImgSrc = ({ target: { value } })=> {
    this.setState({ imgSrcValid: !!imageUrlRegex.exec(value) });
    this.props.setImgSrc( value );
  }
  
  setEventType = ({ target: { value } })=> this.props.setEventType( value )
  setName = ({ target: { value } })=> this.props.setName( value )

  render(){
    const { eventType, name, imgSrc } = this.props;
    const { imgSrcValid } = this.state;
   
    //...
  }
}
```

(we can update the relevant handlers in ```App``` to our desired interface now)


we can also remove ```.imgSrcValid``` from ```App```'s ```.state``` now that that is being kept track of on our ```Promo``` Component's ```.state```

our state initialization here can't just assume that the ```imgSrc``` is invalid like we did before

if we go to another tab and then come back to ```Promo```, we might have a valid imgSrc value in ```App```'s ```state``` that we receive in ```Promo```'s ```props```, so we have to compute the validity in our state initialization.

---


##### Shopping List

so let's render our new ```ShoppingList``` Component into ```App``` so we can start moving code around:

```js
import ShoppingList from './ShoppingList';

//...

<ShoppingList shoppingList={shoppingList}
              onChange={this.onChangeShoppingList}/>
```

and so we can move the JSX from our second tab into ```./src/ShoppingList.js```

```js
//...
  render(){
    const { shoppingList } = this.props;
    
    return (
      <div className='shopping-list form-field'>
        <button onClick={this.addShoppingItem} className='add'>+</button>
        <ul>
          {
            shoppingList.map( ({ item, quantity }, sli)=> (
              <li key={sli}>
                <label htmlFor={`${sli}-sli-item`}>item</label>
                <input id={`${sli}-sli-item`}
                       value={item}
                       onChange={this.setListItem}/>

                <label htmlFor={`${sli}-sli-quantity`}>quantity</label>
                <input id={`${sli}-sli-quantity`}
                       value={quantity}
                       type='number'
                       min={0}
                       onChange={this.setListQuantity}/>

                <button value={sli}
                        onClick={this.removeShoppingItem}
                        className='remove'>
                  X
                </button>
              </li>
            ) )
          }
        </ul>
      </div>
    );
  }
```

and so we'll move our handlers for the shopping list into the Component, and refactor them to call ```this.props.onChange``` instead of using ```this.setState``` as they did until now

```js
//...
  addShoppingItem = ()=>
    this.props.onChange(
      this.props.shoppingList.concat({ item: '', quantity: 0 }) )

  removeShoppingItem = ({ target: { value } })=>
    this.props.onChange(
      this.props.shoppingList.slice(0, value*1)
          .concat( this.props.shoppingList.slice( value*1 +1 ) ) )
  
  setListItem = ({ target: { value, id } })=> {
    const index = parseInt(id, 10);
    
    this.props.onChange(
      this.props.shoppingList.map( (listItem, sli)=>
        (sli !== index) ? listItem : {...listItem, item: value}
      )
    )
  }

  setListQuantity = ({ target: { value, id } })=> {
    const index = parseInt(id, 10);
    
    this.props.onChange(
      this.props.shoppingList.map( (listItem, sli)=>
        (sli !== index) ? listItem : {...listItem, quantity: value}
      )
    )
  }
//...
```

and at last we can update the interface of the ```App``` level handlers to our desired format.


---

##### Invites

so let's render our new ```Invites``` Component into ```App``` so we can start moving code around:

```jsx
import Invites from './Invites';

//...

<Invites invites={invites}
         onChange={this.onChangeInvites}/>
```

and so we can move the JSX from our second tab into ```./src/Invites.js```


```js
  render(){
    const { invites } = this.props;
    const { newInvite } = this.state;
    
    return (
      <div className='invitations form-field'>
        <label htmlFor='new-invite'>New invite - To</label>
        <input value={newInvite} onChange={this.setNewInvite} id='new-invite'/>
        <button onClick={this.addInvite}
                disabled={!newInvite}
                className='add'>
          +
        </button>
        
        <ul>
          {
            invites.map( ({ to, status }, ii)=> (
              <li key={ii}>
                To: {to}
                <select value={status} id={`${ii}-rsvp`}
                        onChange={this.rsvp}>
                  <option value=''>No RSVP</option>
                  <option value='confirmed'>Confirmed</option>
                  <option value='Maybe'>Maybe</option>
                </select>
              </li>
            ))
          }
        </ul>
      </div>
    );
  }
```

and so we'll move our handlers for the invites into the Component, and refactor them to call ```this.props.onChange``` instead of using ```this.setState``` as they did until now


```js
  state = { newInvite: '' }

  setNewInvite = ({ target: { value } })=> this.setState({ newInvite: value })
  
  addInvite = ()=>
    this.props.invites.find(({ to })=> to === this.state.newInvite) || (
      this.setState(state => ({ newInvite: '' }) ),
      this.props.onChange(
        this.props.invites.concat({ to: this.state.newInvite, status: '' })
      )
    )

  rsvp = ({ target: { value, id } })=> {
    const index = parseInt(id, 10);
    
    this.props.onChange(
      this.props.invites.map( (invite, ii)=>
        (index !== ii) ? invite : ({
          ...invite, status: value,
        })
      )
    )
  }
```

and finally we can update our ```App``` handlers to exactly what we wanted at the top of the step

```js
  setName = name=> this.setState({ name })
  setImgSrc = imgSrc=> this.setState({ imgSrc })
  setEventType = eventType=> this.setState({ eventType })

  onChangeShoppingList = shoppingList => this.setState({ shoppingList })
  
  onChangeInvites = invites => this.setState({ invites })
```


at the end of all of that, our ```./src/App.js``` is only 75 lines long. **much better!**



### step 4 sending out data to an API

```
git status # we should have work from step3
git commit -am "all that work from step3"
git checkout step4

# if we want to keep all that work from step3
git merge step3
```

here, we're going to send the event we're making to our API (which is entirely ficticious at this point)

(unimplemented...)


---




[back to index](https://github.com/nikfrank/react-course)

[prev lesson](./2.md)

[next lesson](./4.md)