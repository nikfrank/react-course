Lesson 4

network behaviour: magic internet money exchange and the what if machine

```
cd ~/code/react-course
git clone https://github.com/nikfrank/react-course-workbook-4
cd react-course-workbook-4
yarn
npm start
```

this is going to be our first API call!


## core concepts:

### Promises (asynchronous code)

imagine we have an api we can call for a json of { [coinName]: exchangeRateNumber }

we can load from that API as a response to a user click with:

```js
import React, { Component } from 'react';

class NetworkView extends Component {
  loadExchangeRates = ()=> fetch('https://some.api/for/rates')
                            .then(response => response.json())
                            .then(rates => this.setState({ rates }) )

  render(){
    const { rates={} } = this.state;
    
    return (
      <div>
        <button onClick={this.loadExchangeRates}>Reload</button>
        <ul>
          {
            Object.keys(rates).map(toCoin => (
              <li key={toCoin}>{toCoin} - {rates[toCoin]}</li>
            ) )
          }
        </ul>
      </div>
    );
  }
};

export default NetworkView;
```

the steps of this app runtime are as follows:

- component is rendered by someone else (not shown here!)
- state is initially empty, so all that is rendered is a button and an empty ul
- component sits alone and sad, waiting for user input
- user clicks the button, running the this.loadExchangeRates function
  the function is called with a React-Synthetic event, which is ignored
- that function uses the browser's fetch api to make an http request
- fetch returns a Promise, which is an object representing a future value
  that future value here will be the response of the http call
- each .then chains on a function to run once the previous Promise / then resolves
- the return value (a Promise) of the loadExchangeRates function is ignored
- eventually the http call resolves a response object (google 'browser fetch mdn')
- the Promise then triggers the first .then function, which parses the response as json
- reponse.json() is actually returning a Promise, which the next .then waits for resolving
- the second .then is triggered withe data resolved from the http call json parse
- that function calls this.setState to save the data to the Component's state
- state has changed, so React reconciler triggers a render
- now rates is an object, so Object.keys gives us a list of strings (coinNames here)
- we render the button and a ```<ul>``` with ```<li>```s each displaying an exchange rate 

Using Promise's .then and .catch (for errors) will be very useful in writing our network layer, or when we're writing on the server.

[MDN has a pretty good explanation here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)

I also recommend [this video](https://www.youtube.com/watch?v=8aGhZQkoFbQ) about the js async model


It usually takes a while to get used to js's async / sync code abstraction - it can be useful to play around with setTimeout and console.log until you're comfortable with which code will run when.

---


now the actual lesson


### getting started

```git checkout step0```



##### calling cryptocompare

```js
//...


```




### step 2 the invitation list

```
git status # we should have work from step1
git commit -am "all that work from step1"
git checkout step2

# if we want to keep all that work from step1
git merge step1
```





[back to index](https://github.com/nikfrank/react-course)

[prev lesson](./3.md)
